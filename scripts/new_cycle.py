#!/usr/bin/env python
"""
Python implementation of the cycle scaffolding (replaces the legacy Bash version).

Creates a new agent cycle Markdown file under .agents/cycles/ using
prompt-engineering/TASK_TEMPLATE.md and writes a repo overlay JSON to
.agents/repo_overlay.json, extracting module headers from src/*.rs.
"""

import argparse
import json
import os
import re
import subprocess
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import List, Optional


HEADER_PREFIX_RE = re.compile(r"^\s*(?://+|#+|\*+|/\*+)\s*")
HEADER_FIELD_RE = re.compile(r"^(purpose|role|outputs)\s*:\s*(.*)$", re.I)
INVARIANTS_START_RE = re.compile(r"^invariants\s*:\s*$", re.I)
INVARIANTS_END_RE = re.compile(
    r"^(purpose|role|inputs|outputs|side_effects|errors|tie_breakers)\s*:\s*",
    re.I,
)


@dataclass
class ModuleHeader:
    file: str
    role: Optional[str] = None
    purpose: Optional[str] = None
    outputs: Optional[str] = None
    invariants: Optional[List[str]] = None


def git_root_or_cwd() -> Path:
    try:
        out = subprocess.check_output([
            "git",
            "rev-parse",
            "--show-toplevel",
        ], stderr=subprocess.DEVNULL)
        return Path(out.decode().strip())
    except Exception:
        return Path.cwd()


def kebab_case(s: str) -> str:
    s = s.lower()
    s = re.sub(r"[^a-z0-9]+", "-", s)
    s = s.strip("-")
    return s or "cycle"


def strip_comment_prefix(line: str) -> str:
    return HEADER_PREFIX_RE.sub("", line).rstrip("\n")


def parse_header_for_file(path: Path) -> Optional[ModuleHeader]:
    try:
        with path.open("r", encoding="utf-8", errors="replace") as f:
            lines = [next(f) for _ in range(120)]
    except (FileNotFoundError, StopIteration):
        # StopIteration means file has <120 lines; we still got what we need
        try:
            with path.open("r", encoding="utf-8", errors="replace") as f:
                lines = f.readlines()
        except Exception:
            return None
    except Exception:
        return None

    role = None
    purpose = None
    outputs = None
    invariants: List[str] = []
    in_invariants = False

    for raw in lines:
        line = strip_comment_prefix(raw).strip()
        if not line:
            continue

        if INVARIANTS_START_RE.match(line):
            in_invariants = True
            continue

        if in_invariants:
            if INVARIANTS_END_RE.match(line):
                in_invariants = False
            elif line.startswith("-"):
                inv = line[1:].strip()
                if inv:
                    invariants.append(inv)
            continue

        m = HEADER_FIELD_RE.match(line)
        if m:
            key = m.group(1).lower()
            val = m.group(2).strip()
            if key == "role" and not role:
                role = val
            elif key == "purpose" and not purpose:
                purpose = val
            elif key == "outputs" and not outputs:
                outputs = val

    if any([role, purpose, outputs]) or invariants:
        return ModuleHeader(
            file=str(path),
            role=role or None,
            purpose=purpose or None,
            outputs=outputs or None,
            invariants=invariants or None,
        )
    return None


def scan_src_headers(src_dir: Path) -> List[ModuleHeader]:
    headers: List[ModuleHeader] = []
    if not src_dir.is_dir():
        return headers
    for p in src_dir.rglob("*"):
        if not p.is_file():
            continue
        # Prefer Rust sources; fallback to any file for parity with bash script
        if p.suffix not in {".rs", ""} and p.suffix != ".rs":
            # Allow files without suffix as well, but prioritize .rs
            pass
        mh = parse_header_for_file(p)
        if mh:
            headers.append(mh)
    return headers


def write_cycle_md(
    file_path: Path,
    desc_input: str,
    ts: str,
    repo_root: Path,
    headers: List[ModuleHeader],
) -> None:
    tpl_path = repo_root / "prompt-engineering" / "TASK_TEMPLATE.md"
    template_lines: List[str] = []
    if tpl_path.exists():
        content = tpl_path.read_text(encoding="utf-8", errors="replace").splitlines()
        if content and content[0].lstrip().startswith("# "):
            content = content[1:]
        template_lines = content
    else:
        template_lines = ["[missing prompt-engineering/TASK_TEMPLATE.md]"]

    rel = lambda p: str(Path(p).resolve().relative_to(repo_root))

    with file_path.open("w", encoding="utf-8") as w:
        w.write(f"# Cycle {file_path.stem.split('.',1)[0]} — {desc_input} ({ts})\n\n")
        for line in template_lines:
            w.write(line + "\n")
        w.write("\n---\n")
        w.write("Repo Overlay (autogenerated skeleton)\n\n")
        w.write("States (define enumerated program states here):\n")
        w.write("- [fill: e.g., single, multi, write, preview, split, monolithic]\n\n")

        w.write("Modules → Roles (from file headers):\n")
        if not headers:
            w.write("- [no src directory found]\n\n")
        else:
            any_role_line = False
            for h in headers:
                if h.role or h.purpose:
                    any_role_line = True
                    if h.role and h.purpose:
                        w.write(f"- {rel(h.file)}: {h.role} — {h.purpose}\n")
                    elif h.role:
                        w.write(f"- {rel(h.file)}: {h.role}\n")
                    else:
                        w.write(f"- {rel(h.file)}: {h.purpose}\n")
            if not any_role_line:
                w.write("- [define outputs and contracts here]\n")
            w.write("\n")

        w.write("Module Outputs (from file headers):\n")
        if not headers:
            w.write("- [define outputs and contracts here]\n\n")
        else:
            any_outputs = False
            for h in headers:
                if h.outputs:
                    any_outputs = True
                    w.write(f"- {rel(h.file)} → {h.outputs}\n")
            if not any_outputs:
                w.write("- [define outputs and contracts here]\n")
            w.write("\n")

        w.write("Module Invariants (from file headers):\n")
        if not headers:
            w.write("- [define invariants here]\n\n")
        else:
            any_invariants = False
            for h in headers:
                if h.invariants:
                    any_invariants = True
                    w.write(f"- {rel(h.file)}\n")
                    for inv in h.invariants:
                        w.write(f"  - {inv}\n")
            if not any_invariants:
                w.write("- [define invariants here]\n")
            w.write("\n")

        w.write("Acceptance (checklist to adapt):\n")
        w.write("- [ ] Program state derived once and stored centrally\n")
        w.write("- [ ] Outputs mapped to enumerated states\n")
        w.write("- [ ] Names/shapes stable and test-covered\n")
        w.write("- [ ] Orchestrator phases clear; IO at edges\n")
        w.write("- [ ] Invariants defined and asserted\n")
        w.write("- [ ] Errors include what/where\n")
        w.write("- [ ] Observability: pointers/ids/paths logged/printed\n\n")

        w.write("Cycle Metadata (prefilled)\n\n")
        w.write(f"- Cycle id: {file_path.stem.split('.',1)[0]}\n")
        w.write(f"- Short description: {desc_input}\n")
        w.write(f"- Timestamp: {ts}\n")
        w.write(f"- File: {rel(file_path)}\n")


def write_overlay_json(path: Path, repo_root: Path, ts: str, headers: List[ModuleHeader]) -> None:
    modules = []
    for h in headers:
        rel_file = str(Path(h.file).resolve().relative_to(repo_root))
        entry = {"file": rel_file}
        if h.role:
            entry["role"] = h.role
        if h.purpose:
            entry["purpose"] = h.purpose
        if h.outputs:
            entry["outputs"] = h.outputs
        if h.invariants:
            entry["invariants"] = h.invariants
        modules.append(entry)

    obj = {
        "repo": str(repo_root),
        "generated_at": ts,
        "modules": modules,
    }
    path.write_text(json.dumps(obj, ensure_ascii=False, indent=0), encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description="Create a new agent cycle file")
    parser.add_argument("desc", help="short description for the cycle")
    args = parser.parse_args()

    repo_root = git_root_or_cwd()
    agents_dir = repo_root / ".agents"
    cycles_dir = agents_dir / "cycles"
    cycles_dir.mkdir(parents=True, exist_ok=True)
    agents_dir.mkdir(parents=True, exist_ok=True)

    # Determine next index (4-digit, zero-padded)
    idx_values = []
    for p in cycles_dir.glob("*.md"):
        m = re.match(r"^(\d{4})\.", p.name)
        if m:
            try:
                idx_values.append(int(m.group(1)))
            except ValueError:
                pass
    next_idx = (max(idx_values) + 1) if idx_values else 1
    idx_str = f"{next_idx:04d}"

    norm_desc = kebab_case(args.desc)
    ts = datetime.now().strftime("%Y-%m-%dT%H-%M-%S")

    file_name = f"{idx_str}.{norm_desc}.{ts}.md"
    file_path = cycles_dir / file_name
    overlay_json_path = agents_dir / "repo_overlay.json"

    headers = scan_src_headers(repo_root / "src")

    write_cycle_md(file_path, args.desc, ts, repo_root, headers)
    print(f"Created {file_path}")

    write_overlay_json(overlay_json_path, repo_root, ts, headers)
    print(f"Wrote {overlay_json_path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
