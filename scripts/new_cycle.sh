#!/usr/bin/env bash
set -euo pipefail

desc_input=${1:-}
if [[ -z "${desc_input}" ]]; then
  echo "usage: bash scripts/new_cycle.sh \"short description\"" >&2
  exit 2
fi

# repo root
if git rev-parse --show-toplevel >/dev/null 2>&1; then
  GITROOT=$(git rev-parse --show-toplevel)
else
  GITROOT=$(pwd)
fi

CYC_DIR="$GITROOT/.agents/cycles"
mkdir -p "$CYC_DIR"
mkdir -p "$GITROOT/.agents"

# next index
last_idx=$(ls -1 "$CYC_DIR"/*.md 2>/dev/null | sed -E 's#.*/([0-9]{4})\..*#\1#' | sort -n | tail -n1 || true)
if [[ -z "${last_idx:-}" ]]; then
  next_idx=1
else
  next_idx=$((10#$last_idx + 1))
fi
idx=$(printf "%04d" "$next_idx")

# normalize description to kebab-case
norm_desc=$(echo "$desc_input" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+//; s/-+$//')

# timestamp (local)
ts=$(date +"%Y-%m-%dT%H-%M-%S")

file="$CYC_DIR/$idx.$norm_desc.$ts.md"
overlay_json="$GITROOT/.agents/repo_overlay.json"

# json string escape helper
json_escape() {
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\n'/\\n}"
  echo -n "$s"
}

{
  echo "# Cycle $idx — $desc_input ($ts)"
  echo
  if [[ -f "$GITROOT/docs/TASK_TEMPLATE.md" ]]; then
    # print template without the leading title line if present
    awk 'NR==1 && /^# /{next} {print}' "$GITROOT/docs/TASK_TEMPLATE.md"
  else
    echo "[missing docs/TASK_TEMPLATE.md]"
  fi
  echo
  echo "---"
  echo "Repo Overlay (autogenerated skeleton)"
  echo
  echo "States (define enumerated program states here):"
  echo "- [fill: e.g., single, multi, write, preview, split, monolithic]"
  echo
  echo "Modules → Roles (from file headers):"
  modules_json="["
  first_mod=1
  if [[ -d "$GITROOT/src" ]]; then
    while IFS= read -r -d '' f; do
      # parse top 120 lines for header fields; support //, #, /*, * comment prefixes
      header=$(head -n 120 "$f" | awk '
        function trim(s){ sub(/^ +|\t+/,"",s); sub(/ +$/,"",s); return s }
        {
          line=$0
          gsub(/^[[:space:]]*(\/\/+|#+|\*+|\/\*+)[[:space:]]*/,"",line)
          if (line ~ /^role:[[:space:]]*/) { role=line; sub(/^role:[[:space:]]*/, "", role); role=trim(role) }
          if (line ~ /^purpose:[[:space:]]*/) { purpose=line; sub(/^purpose:[[:space:]]*/, "", purpose); purpose=trim(purpose) }
          if (line ~ /^outputs:[[:space:]]*/) { outputs=line; sub(/^outputs:[[:space:]]*/, "", outputs); outputs=trim(outputs) }
          if (line ~ /^invariants:[[:space:]]*$/) { inv=1; next }
          if (inv==1) {
            if (line ~ /^(purpose|role|inputs|outputs|side_effects|errors|tie_breakers)[[:space:]]*:/) { inv=0 }
            else if (line ~ /^-[[:space:]]*/) { invline=line; sub(/^-+[[:space:]]*/, "", invline); print "invariant=" trim(invline) }
          }
        }
        END {
          if (length(role) || length(purpose)) {
            printf("role=%s\npurpose=%s\n", role, purpose)
          }
          if (length(outputs)) { printf("outputs=%s\n", outputs) }
        }')
      role=$(echo "$header" | awk -F= '/^role=/{print substr($0,6)}' || true)
      purpose=$(echo "$header" | awk -F= '/^purpose=/{print substr($0,9)}' || true)
      outputs=$(echo "$header" | awk -F= '/^outputs=/{print substr($0,9)}' || true)
      mapfile -t invariants < <(echo "$header" | awk -F= '/^invariant=/{print substr($0,11)}')
      if [[ -n "$role$purpose" ]]; then
        rel=${f#"$GITROOT/"}
        if [[ -n "$role" && -n "$purpose" ]]; then
          echo "- $rel: $role — $purpose"
        elif [[ -n "$role" ]]; then
          echo "- $rel: $role"
        else
          echo "- $rel: $purpose"
        fi
      fi
      if [[ -n "$role$purpose$outputs" || ${#invariants[@]} -gt 0 ]]; then
        [[ $first_mod -eq 0 ]] && modules_json+=" ," || first_mod=0
        rel_path=${f#"$GITROOT/"}
        entry="{\"file\":\"$(json_escape "$rel_path")\""
        if [[ -n "$role" ]]; then entry+=" ,\"role\":\"$(json_escape "$role")\""; fi
        if [[ -n "$purpose" ]]; then entry+=" ,\"purpose\":\"$(json_escape "$purpose")\""; fi
        if [[ -n "$outputs" ]]; then entry+=" ,\"outputs\":\"$(json_escape "$outputs")\""; fi
        if [[ ${#invariants[@]} -gt 0 ]]; then
          entry+=" ,\"invariants\":["
          inv_first=1
          for inv in "${invariants[@]}"; do
            [[ $inv_first -eq 0 ]] && entry+=" ," || inv_first=0
            entry+="\"$(json_escape "$inv")\""
          done
          entry+="]"
        fi
        entry+=" }"
        modules_json+="$entry"
      fi
    done < <(find "$GITROOT/src" -type f -print0)
  else
    echo "- [no src directory found]"
  fi
  echo
  echo "Module Outputs (from file headers):"
  if [[ -d "$GITROOT/src" ]]; then
    while IFS= read -r -d '' f; do
      outs=$(head -n 120 "$f" | awk '
        function trim(s){ sub(/^ +|\t+/,"",s); sub(/ +$/,"",s); return s }
        {
          line=$0
          gsub(/^[[:space:]]*(\/\/+|#+|\*+|\/\*+)[[:space:]]*/,"",line)
          if (line ~ /^outputs:[[:space:]]*/) { out=line; sub(/^outputs:[[:space:]]*/, "", out); out=trim(out) }
        }
        END { if (length(out)) print out }')
      if [[ -n "$outs" ]]; then
        rel=${f#"$GITROOT/"}
        echo "- $rel → $outs"
      fi
    done < <(find "$GITROOT/src" -type f -print0)
  else
    echo "- [define outputs and contracts here]"
  fi
  echo
  echo "Module Invariants (from file headers):"
  if [[ -d "$GITROOT/src" ]]; then
    while IFS= read -r -d '' f; do
      invs=$(head -n 120 "$f" | awk '
        function trim(s){ sub(/^ +|\t+/,"",s); sub(/ +$/,"",s); return s }
        {
          line=$0
          gsub(/^[[:space:]]*(\/\/+|#+|\*+|\/\*+)[[:space:]]*/,"",line)
          if (line ~ /^invariants:[[:space:]]*$/) { inv=1; next }
          if (inv==1) {
            if (line ~ /^(purpose|role|inputs|outputs|side_effects|errors|tie_breakers)[[:space:]]*:/) { inv=0 }
            else if (line ~ /^-[[:space:]]*/) { invline=line; sub(/^-+[[:space:]]*/, "", invline); print trim(invline) }
          }
        }')
      if [[ -n "$invs" ]]; then
        rel=${f#"$GITROOT/"}
        echo "- $rel"
        while IFS= read -r inv; do
          echo "  - $inv"
        done <<< "$invs"
      fi
    done < <(find "$GITROOT/src" -type f -print0)
  else
    echo "- [define invariants here]"
  fi
  echo
  echo "Acceptance (checklist to adapt):"
  echo "- [ ] Program state derived once and stored centrally"
  echo "- [ ] Outputs mapped to enumerated states"
  echo "- [ ] Names/shapes stable and test-covered"
  echo "- [ ] Orchestrator phases clear; IO at edges"
  echo "- [ ] Invariants defined and asserted"
  echo "- [ ] Errors include what/where"
  echo "- [ ] Observability: pointers/ids/paths logged/printed"
  echo
  echo "Cycle Metadata (prefilled)"
  echo
  echo "- Cycle id: $idx"
  echo "- Short description: $desc_input"
  echo "- Timestamp: $ts"
  echo "- File: $file"
} > "$file"

echo "Created $file" >&2

# Write overlay JSON for agents
modules_json+="]"
{
  echo -n '{'
  echo -n '"repo":"'; json_escape "$GITROOT"; echo -n '",'
  echo -n '"generated_at":"'; json_escape "$ts"; echo -n '",'
  echo -n '"modules":'; echo -n "$modules_json"
  echo '}'
} > "$overlay_json"

echo "Wrote $overlay_json" >&2
