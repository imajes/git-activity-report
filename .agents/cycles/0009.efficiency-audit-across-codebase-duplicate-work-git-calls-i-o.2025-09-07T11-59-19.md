# Cycle 0009 — Efficiency audit across codebase (duplicate work, git calls, I/O) (2025-09-07T11-59-19)


Use this template before editing code. Keep it short and decisive. Save a copy as `$GITROOT/.agents/cycles/<idx>.<short-desc>.<timestamp>.md` to log each cycle.

1) Summary

- Problem/intent:
  Perform an honest, detailed efficiency audit of the hot paths (commit processing, rendering, enrichment) and identify duplicate work, excessive subprocess calls, and I/O hotspots.
- Deliverables (code/docs/tests):
  Written audit with prioritized, low‑risk refactors and concrete sketches; no behavior changes in this cycle.
- Scope (modules/files/areas):
  `src/render.rs`, `src/commit.rs`, `src/gitio.rs`, `src/enrichment/*`, `src/range_processor.rs`, `src/util.rs`.

2) Context & Constraints

- Domain context (what system does):
- Primary consumers (humans/services):
- External contracts (APIs/schemas/CLIs):

3) State & Invariants

- State variables (k: description):
- Derived state (computed once):
- Invariants (pre/post, must always hold):

4) Inputs → Outputs (Contracts)

- Inputs (flags, env, APIs, files):
- Outputs (files, API responses, console):
- Naming/shape contracts (stable filenames/paths; schema versions; pointer shapes):

5) Orchestration Plan (Phases)

- Phase 1 — Normalize/build inputs:
  Survey code and tests to map expensive paths (git calls, JSON writes, network).
- Phase 2 — Resolve/derive:
  Identify duplicate work and caching opportunities; score by impact×risk.
- Phase 3 — Process units (loop): generate → save/persist → index
  Draft concrete proposals with rough diffs/entry points; defer code changes.
- Finalize — aggregate/manifest → emit/return
  Summarize findings + next‑cycle plan for surgical changes.

6) Module/Boundary Plan

- Resolution/parser module(s):
- Processing/orchestrator module(s):
- Assembly/rendering module(s):
- Persistence/manifest module(s):
- Enrichment/integration module(s):
- Utilities/helpers:

7) Side Effects & IO

- Filesystem (paths, write strategy):
- Network/API calls (best-effort vs. required):
- Subprocess/system calls:
- Concurrency decisions:

8) Testing & Validation

- Unit tests (pure helpers):
- Contract tests (schemas/pointers/naming):
- Integration tests (end-to-end scenarios):
- Manual checks (smoke/paths/outputs):

9) Risks & Trade-offs

- Purity vs. performance:
- Stability vs. ergonomics:
- Backward compatibility/migration:

10) Tie-Breakers (apply in this order)

1. Contract stability (filenames/schemas/protocols)
2. Orchestration simplicity (single loop, explicit state)
3. Correctness/testability (pure helpers, invariants)
4. Performance (avoid duplicate heavy work)
5. Minimal diff/readability

11) Observability & Rollback

- Logs/metrics/counters:
- Pointer/evidence to outputs:
- Rollback plan:

12) Cycle Metadata

- Cycle id:
- Short description:
- Timestamp (start/end):
- Links (PR/issues):

---
Findings (ranked by impact)

1) Split mode recomputes every commit twice
- Where: `render::run_report` calls `process_commit_range` (which builds full `Commit`s, writes shard JSON, accumulates authors/summary), then immediately re‑lists SHAs and calls `process_commit` again for each commit to embed them into the final report.
- Cost: For N commits, each costs ~4–5 `git` calls; duplicating doubles wall time and CPU for large ranges.
- Fix (low risk): Return `Vec<Commit>` from `process_commit_range` (or read back the just‑written shards) and reuse for the final `SimpleReport`. Remove the second `rev_list`/loop entirely.
- Secondary: Unify patch‑saving between these phases; avoid saving twice.

2) Double fetch of patch content when embed + save
- Where: `commit::process_commit` may fetch full patch (to clip + embed lines), and `commit::save_patch_to_disk` fetches full patch again.
- Cost: Large patches are expensive; two full `git show` calls per commit when both options enabled.
- Fix (low risk): If `include_patch=true`, pass already‑fetched patch to `save_patch_to_disk` (write from memory when not clipped; fall back to `git show` only when clipped or `include_patch=false`).

3) Per‑commit origin parsing for GitHub enrichment
- Where: `enrich_with_github_prs` calls `parse_origin_github(repo)` for each commit.
- Cost: Spawns `git config --get remote.origin.url` N times; unnecessary.
- Fix (low risk): Cache `(owner, repo)` per `repo` in `ProcessContext` (or a `once_cell` HashMap). Pass it into enrichment calls.

4) Extra `git show --shortstat` per commit
- Where: `commit::build_commit_object` calls `commit_shortstat` in addition to `commit_numstat`.
- Cost: One extra process per commit.
- Fix (low risk): Derive the shortstat string from `numstat` totals (files changed + insertions/deletions). Matches git’s wording well enough for the report.

5) Pretty JSON for every shard
- Where: `process_commit_range` and unmerged branch shards use `serde_json::to_vec_pretty`.
- Cost: Pretty printing is slower and larger on disk; multiplied by shard count.
- Fix (very low risk): Write shards with compact `serde_json::to_vec` (keep pretty for top‑level report). If snapshots depend on formatting, gate via a flag (e.g., `--pretty-shards`).

6) Unmerged branches computed but omitted from report
- Where: In split mode, `process_unmerged_branches` runs when `include_unmerged`, but the resulting `UnmergedActivity` is not embedded (assigned to `_unmerged_activity` then dropped).
- Cost: Wasted compute when user expected it in output; at minimum, unclear behavior.
- Fix (medium risk): Either (a) embed `unmerged_activity` into `SimpleReport`, or (b) document that only shard files are produced. If (b), consider deferring the compute.

7) GitHub reviewer/user lookups not cached across PRs
- Where: `enrichment/github_pull_requests.rs` calls `get_user_json` per unique login per PR; approver path can call again.
- Cost: Extra HTTP calls for repos with many reviewers.
- Fix (low risk): Per‑run LRU or `HashMap<String, serde_json::Value>` cache injected into the API seam to reuse user JSON.

8) Multiple small subprocesses vs. batched git
- Where: Per‑commit `git show` for meta, numstat, name‑status, and patch.
- Cost: Process spawn overhead dominates on large N.
- Fix (higher effort): Batch via `git log` over the window (once) to parse meta; combine `--numstat --name-status -z` where feasible; or adopt `git2` (tradeoffs).

9) Streaming limit for huge patches
- Where: `run_git` reads full patch into memory; `clip_patch` trims afterward.
- Cost: Memory/time spike on mega‑patches.
- Fix (medium effort): Add `run_git_limited(repo, args, max_bytes)` to stream stdout up to `max_bytes` (plus UTF‑8 guard), used when `include_patch=true` with a limit.

Quick Wins (proposed next cycle)
- R1: Reuse commits in split mode (remove second pass) and unify patch saving.
- R2: Cache origin once per run; thread through `ProcessContext`.
- R3: Synthesize `diffstat_text` from numstat; drop `--shortstat` call.
- R4: Write shards compact; keep pretty for top‑level.

Implemented Now (this cycle)
- Added an in‑memory caching wrapper `GithubCachedApi` that wraps any `GithubApi` backend (env/http).
- Cached endpoints: PRs for commit, PR details, PR reviews, PR commits (JSON and typed), and user lookups by login.
- Wired caching into all constructors (`build_api`, `make_env_api`, `make_http_api`, `make_default_api`).
- Behavior: transparent, per‑run cache; preserves existing test seams; reduces duplicate remote calls.

Also Implemented (R1–R4)
- R1: Removed duplicate commit processing in split mode. `process_commit_range` now returns `(commits, items, summary, authors)`, and `run_report` reuses the returned `commits` for the final report (no second `rev-list` + loop). Patch saving remains in the first pass only.
- R2: Cached GitHub origin parsing per repo inside `parse_origin_github` using a static in‑process cache, eliminating repeated `git config --get remote.origin.url` calls across commits.
- R3: Dropped extra `git show --shortstat` per commit. `commit::build_commit_object` synthesizes `diffstat_text` from `numstat` (omits zero components to match Git’s output).
- R4: Wrote shard files with compact JSON (`to_vec`) while keeping pretty formatting for top‑level reports and manifests.

Validation
- `just test`: 96/96 passing.
- `just audit-spacing-strict`: clean.

Clippy Cleanup
- Ran `just clippy` with `-D warnings`; fixed all findings.
- `gitio::commit_shortstat` is now `#[cfg(test)]` (used only by module tests).
- Introduced type aliases to reduce tuple/static type complexity:
  - `type OriginCache = Mutex<HashMap<String, Option<(String, String)>>>;`
  - `type ProcessRangeOut = (Vec<Commit>, Vec<ManifestItem>, ChangeSet, BTreeMap<String, i64>);`
- Result: `just clippy` passes with no warnings.

Additional Optimization
- Save patch from memory when already fetched and not clipped. `save_patch_to_disk` now writes from `commit.patch_lines` when `patch_clipped == Some(false)`, avoiding a second `git show`. Falls back to `git show` when clipped or not embedded.

Sketches
- R1 entry points: `render::process_commit_range` → return `(Vec<Commit>, Vec<ManifestItem>, ChangeSet, BTreeMap<String,i64>)` or a struct; adjust `run_report` to reuse the `commits` vec; delete the second `rev_list` and loop.
- R2 entry points: add `origin: Option<(String,String)>` to `ProcessContext`; compute once in `run_simple`/`run_report` and pass to `commit::process_commit` → `enrich_with_github_prs` uses provided origin.
- R3 entry points: add helper `diffstat_from_numstat(&[FileEntry]) -> String`; use in `build_commit_object`; drop `commit_shortstat` call.
- R4 entry points: replace `to_vec_pretty` with `to_vec` in shard writers; keep pretty for `report-<label>.json`.

Risk Notes
- All suggested changes are behavior‑preserving at the JSON field level; only performance/formatting of shard files may change (address via flag if needed).

Next Steps
- If approved, I’ll implement R1–R4 in the next cycle, gated behind small, testable commits.


---
Repo Overlay (autogenerated skeleton)

States (define enumerated program states here):
- [fill: e.g., single, multi, write, preview, split, monolithic]

Modules → Roles (from file headers):
- src/commit.rs: commit construction/enrichment — Construct per-commit objects; enrich with optional PR links; embed or save patches as configured
- src/gitio.rs: git/io-helpers — Provide thin, robust wrappers around `git` CLI to retrieve commit metadata, diffs, stats, and branch info for report generation
- src/util.rs: utilities/helpers — Utilities for paths, time formatting, spacing-safe helpers, and man page rendering
- src/render.rs: assembly/render — Assemble per-range reports; when split_apart, write commit shards and per-range report, returning a pointer
- src/enrich.rs: enrichment/coordinator — Coordinator to apply configured enrichments; keeps orchestration separate from enrichment implementations
- src/manifest.rs: persistence/manifest — Build and write overall manifest for multi-range runs
- src/main.rs: entrypoint/orchestrator — Entrypoint orchestrator; normalize → resolve ranges → process ranges; print final JSON or pointer
- src/range_windows.rs: resolution/parser — Resolve time windows into labeled ranges; parse "now" overrides; helpers for natural language buckets
- src/range_processor.rs: processing/orchestrator — Orchestrate per-range processing: generate report JSON and save artifacts; assemble overall manifest for multi-range runs
- src/model.rs: model/types — Define the JSON model (commits, ranges, manifests, GitHub PRs) shared by rendering and enrichment
- src/cli.rs: cli/normalization — Parse CLI flags and produce an EffectiveConfig with consistent defaults and implied flags
- src/ext/mod.rs: module/aggregation — Group extension traits and helpers for third-party crates and std types under a single `ext` namespace
- src/ext/serde_json.rs: extension/serde_json — Provide ergonomic nested JSON fetching via dotted paths and safe typed extraction for serde_json::Value
- src/enrichment/github_api.rs: enrichment/github-api — Isolated GitHub API helpers used by enrichment (token discovery, REST calls)
- src/enrichment/github_pull_requests.rs: enrichment/integration — Best-effort enrichment adding GitHub PR links and PR list to a commit
- src/enrichment/mod.rs: enrichment/namespace — Namespace for enrichment features (GitHub PRs, etc.)

Module Outputs (from file headers):
- src/commit.rs → Commit structs with files/diffstat/patch_ref; optional patch text and saved patch files
- src/gitio.rs → Parsed commit meta, numstat/name-status, shortstat, patch text; branch names and ahead/behind/merged signals
- src/util.rs → Canonicalized paths, formatted timestamps, directories ensured, man page text
- src/render.rs → SimpleReport JSON (non-split) or pointer {dir, file} (split)
- src/enrich.rs → Mutates Commit (per-commit enrichments) and returns optional aggregated enrichments for reports
- src/manifest.rs → manifest.json file written under base_dir
- src/main.rs → Either full JSON to stdout, or a pointer {dir,file}/{dir,manifest} to stdout; files on disk when split/multi
- src/range_windows.rs → Vec<LabeledRange> (chronological earliest→latest); parsed DateTime for now when requested
- src/range_processor.rs → Files on disk (reports, shards), optional manifest.json; stdout pointer or JSON per state
- src/model.rs → Serializable structs with stable field names and optional enrichment fields
- src/cli.rs → EffectiveConfig with normalized paths and flags; multi_windows is initialized false (set later)
- src/ext/mod.rs → Re-exported submodules providing utility traits and helpers (e.g., JsonFetch)
- src/ext/serde_json.rs → JsonFetch trait and JsonFetched wrapper for typed extraction with defaults
- src/enrichment/github_api.rs → JSON values and typed commit snapshots for PRs
- src/enrichment/github_pull_requests.rs → Mutated commit.patch_ref (diff/patch URLs) and commit.github_prs
- src/enrichment/mod.rs → Public submodules implementing specific enrichments

Module Invariants (from file headers):
- src/commit.rs
  - clip_patch preserves UTF-8 boundaries; patch_clipped is accurate
  - body_lines derived when body is non-empty
  - enrichment is best-effort; absence of PRs leaves fields None
- src/util.rs
  - prepare_out_dir returns an existing directory (either provided or temp timestamped)
  - clip_patch never splits UTF-8; indicates clipping accurately
  - format_shard_name pattern is stable and locale-independent
- src/render.rs
  - run_simple returns fully in-memory report consistent with schema
  - run_report returns pointer JSON when split; otherwise full report JSON; file names are stable
  - shard filenames follow YYYY.MM.DD-HH.MM-<shortsha>.json
- src/manifest.rs
  - manifest contains ranges[] in chronological order of entries provided
  - file paths in entries are relative to base_dir and point to report-<label>.json
  - generated_at is serialized in %Y-%m-%dT%H:%M:%S (local)
- src/main.rs
  - when cfg.multi_windows == true, an overall manifest.json is written and a pointer with {dir, manifest} is printed
  - when cfg.split_apart == true and cfg.multi_windows == false, a pointer {dir, file} is printed for the range report
  - when cfg.split_apart == false and cfg.multi_windows == false, a full JSON report is printed to stdout or written to --out
- src/range_windows.rs
  - resolve_ranges returns at least one range; ForPhrase buckets are ordered earliest→latest
  - month_bounds yields [start_of_month, start_of_next_month]
  - parse_now accepts RFC3339 or naive %Y-%m-%dT%H:%M:%S and never panics
- src/range_processor.rs
  - base_dir is prepared when split_apart || multi_windows
  - per-range report file name is report-<label>.json when written to disk
  - multi_windows ⇒ manifest.json exists and pointer {dir, manifest} printed
  - single split ⇒ pointer {dir, file} printed; single non-split ⇒ JSON printed or written to --out
- src/cli.rs
  - exactly one window selection is provided: --month | --for | (--since & --until)
  - --detailed implies include_unmerged/include_patch/github_prs
  - out semantics: file path when single non-split; directory when split or multi
- src/enrichment/github_api.rs
  - Never panic; return None/empty on failures (best-effort enrichment)
  - Token discovery prefers GITHUB_TOKEN, then `gh auth token`
  - Origin parser only recognizes GitHub remotes (https or ssh)
- src/enrichment/github_pull_requests.rs
  - On success, preserves existing commit fields; sets URLs if present in first PR; attaches PR list
  - On failure, commit remains valid; fields untouched

Acceptance (checklist to adapt):
- [ ] Program state derived once and stored centrally
- [ ] Outputs mapped to enumerated states
- [ ] Names/shapes stable and test-covered
- [ ] Orchestrator phases clear; IO at edges
- [ ] Invariants defined and asserted
- [ ] Errors include what/where
- [ ] Observability: pointers/ids/paths logged/printed

Cycle Metadata (prefilled)

- Cycle id: 0009
- Short description: Efficiency audit across codebase (duplicate work, git calls, I/O)
- Timestamp: 2025-09-07T11-59-19
- File: .agents/cycles/0009.efficiency-audit-across-codebase-duplicate-work-git-calls-i-o.2025-09-07T11-59-19.md
